/*
// 텍스처
텍스처는 쉐이더가 읽기도 하고 쓰기도 하는 구조화된 스토리지 형식을 갖는다. 
대부분 이미지 데이터를 저장할 때 사용되지만, 여러 다른 용도로 사용할 수도 있다. 
아마도 가장 일반적인 텍스처 레이아웃은 2차원일 것이다. 
하지만 켁스처는 1차원이나 3차원 레이아웃으로, 배열 형태로 (여러 텍스처가 논리적인 객체를 구성하기 위해 함께 묶인), 또는 정육면체 등의 형태로
생성할 수 있다. 
텍스처는 생성할 수 있고, 텍스처 유닛에 바인딩되고, 관리할 수 있는 객체 형태로 표현된다. 
텍스처를 생성하려면, 우선 glGenTextures()를 호출하여 OpenGL에 이름을 예약한다. 
이 시점에서 이름은 생성할 텍스처 객체일 뿐이며, 텍스처 타깃에 바인딩되는 시점에야 비로소 텍스처로 태어난다고 할 수 있다. 
이것은 버퍼 객체를 버퍼 바인딩 포인트에 바인딩하는 것과 유사하다. 
하지만 일단 텍스처 이름이 텍스처 타깃에 바인딩되면, 소멸할 때까지 해당 타깃의 타입이 유지된다. 

// 텍스처 생성 및 초기화 
텍스처를 생성하려면 이름을 생성하고, 그 이름을 텍스처 타깃에 바인딩하고, OpenGL에 저장할 이미지 사이즈를 알려줘야 한다. 
객체 이름을 예약하고, 타깃에 바인딩하고, 담을 데이터에 대한 스토리지를 정의하는 것은 공통적으로 거쳐야하는 과정이다. 

// 밉맵
밉맵(mipmap)은 렌더링 성능과 비주얼 퀄리티를 모두 향상시킬 수 있는 강력한 텍스처 기법이다. 
표준 텍스처 매핑에는 잘 알려진 두 가지 문제가 있다. 
첫 번째는 반짝거림 현상(scintillation)또는 계단 현상으로, 적용된 텍스처 크기에 비해 매우 작은 크기로 화면에 렌더링되는 객체의 서피스에 나타나는 현상이다. 
반짝거림 현상은 텍스처 맵의 샘플링 영역이 화면 크기에 비례해서 변하지 않을 때 발생한다. 
반짝거림 현상의 부작용은 카메라 또는 객체가 움직일 때 더 잘 확인할 수 있다. 

두 번째 문제는 성능에 관련된 것이지만 반짝거림 현상과 동일한 환경에서 발생한다. 
즉, 텍스처를 담기 위해 많은 텍스처 메모리가 사용되는 경우, 
화면 상의 인접 프래그먼트가 실제 텍스처 공간 상에서 멀리 떨어진 텍셀들과 근접하는 경우가 발생한다. 
텍스처 크기가 크고 드문드문 엑세스하는 경우에는 텍스처링 성능이 더 낮아진다. 

이 두 가지 문제에 대한 해결책은 간단히 더 작은 텍스처 맵을 사용하는 것이다. 
하지만 이 솔루션은 새로운 문제를 일으킨다. 
객체가 가까운 경우 크게 렌더링되어야 하는데, 텍스처 맵이 작으면 늘어나게 되어 너무 뭉게져버리거나 블록 현상이 두드러지게 된다. 
이 문제에 대한 해결책은 밉맵을 사용하는 것이다. 
밉맵은 라틴 어구인 'multum in parvo'에서 왔는데, '작은 공간에 많은 것을'이라는 의미다.
기본적으로 텍스처 객체에 하나의 이미지만 로딩하지 않고 크기에 까라 여러 이미지를 사용하여 하나의 '밉맵' 텍스처를 로딩한다. 
OpenGL은 일련의 필터 모드를 사용하여 해당 지오메트리에 대해 가장 적합한 텍스처를 선택한다. 
메모리(및 프로세싱 작업)를 추가해서 깜박거림 현상과 멀리 있는 객체의 텍스처 머모리 성능 저하 문제를 동시에 해결할 수 있다. 
게다가 필요한 경우 높은 해상도의 텍스처도 유지할 수 있다. 

밉맵 텍스처는 여러 텍스처 이미지로 구성된다. 
각 이미지는 이전 단계의 이미지에 비해 각 축에 대해 절반 크기거나 픽셀 개수로는 4분의 1에 해당한다. 
밉맵 레벨은 정방형일 필요는 없지만, 각 차원에 대해 절반 크기로 줄여나가면 결국 마지막 이미지는 1×1 텍셀이 된다. 
한 차원이 1이 되면, 그 다음부터는 다른 차원만 나눈다. 
2D 텍스처의 경우, 정방형 밉맵을 사용하면 밉맵을 사용하지 않는 경우에 비해 메모리가 3분의 1 가량 더 필요하다. 

// 배열 텍스처


*/
